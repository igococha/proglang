\documentstyle[/homes/daveb/doc/exam_style/cityexam,11pt]{article}
\begin{document}
\examnumber{00.00}
\begin{preamble}
\degrees{EC2 retread}
\part{II}
\title{Programming Systems and Principles of Programming Languages}
\examdate{XXX, 00 XXX, 1994}
\examtime{00 to 00}
\rubric{Two from section A, two from B}
\end{preamble}
\externals{XXX \\ XXX}
\internals{S Hunt \\ DJ Bolton}

\begin{questions}

% Herewith two questions for Principles and Tools

\question

\newenvironment{bnf}{
    \begin{tabbing}
    XXXXXXX \= XXXX \= XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\kill}{
    \end{tabbing}
    }

\newcommand{\nt}[1]{{\it #1\/}}
\newcommand{\Or}[1]{\ \ $|$ \ \ #1}
\newcommand{\Rule}[2]{{\it #1} \> $\rightarrow$ \> #2}


The following is an extract from a possible BNF syntax for
a subset of an Eiffel-like programming language: 
\begin{bnf}
\Rule{\nt{Compound\ }}{\nt{Instruction} \verb";" \nt{Compound}\Or{\nt{Instruction}}} \\
\Rule{\nt{Instruction\ }}{\nt{Loop}\Or{\ldots}} \\
\Rule{\nt{Loop}}{\verb"from" \nt{Compound$_1$} \verb"until" \nt{BoolExp} \verb"loop" \nt{Compound$_2$} \verb"end"}\\
\Rule{\nt{IntExp}}{\nt{IntVar}\Or{\nt{IntConstant}}\Or{\nt{IntExp} \verb"+" \nt{IntExp}}
        \Or{\nt{IntExp} \verb"*" \nt{IntExp}}}\\
\Rule{\nt{BoolExp}}{\nt{IntExp} \verb"=" \nt{IntExp}\Or{\nt{IntExp} \verb"<=" \nt{IntExp}}}
\end{bnf}
where \nt{IntVar} is a variable attribute of type INTEGER, \nt{IntConstant}
is an INTEGER type constant (eg 3).
\begin{subquestions}
\subquestion
Show that the grammar rules for \nt{IntExp} are ambiguous. 
\marks{20}
\subquestion
Write down an abstract syntax for a \nt{Loop}, \nt{BoolExp} and \nt{IntExp}.
\marks{10}
\subquestion
The meaning of a \nt{Loop} is as follows:
\begin{itemize}
\item The effect of a \nt{Loop} is the effect of executing 
	the Initialisation \nt{Compound$_1$}
	followed by the rest of the loop.
\item The effect of executing the rest of the loop
	\verb|until| \ldots\ \verb|end|
	is to leave the
	state of the computation unchanged if the \nt{BoolExp}
	evaluates to true.
\item Otherwise, when the \nt{BoolExp} evaluates to false,
	it is the effect of executing \nt{Compound$_2$},
	followed by the effect of executing the rest of the loop
	\verb|until| \ldots\ \verb|end| again in the resulting state.
\end{itemize}
\begin{subsubquestions}
\subsubquestion
	Outline the structure of the
        code that might be generated in translation of
        a \nt{Loop} with an example \nt{BoolExp} (\verb"a+1 <= b*2", say). 
	Assume code generation for a simple
        stack machine, and briefly explain the
	instructions you use in your outline.
\marks{30}
\subsubquestion
        Construct a syntax-directed translation for 
        \nt{Loop} and \nt{BoolExp} which produces such code.
        Describe any attributes you
        introduce, and make clear any assumptions you make about 
        the attributes and code generated for the
        expressions \nt{IntExp}, but you need not produce translations for
	\nt{IntExp}.
\marks{40}
\end{subsubquestions}

\end{subquestions}

\question

\begin{subquestions}
\subquestion
Draw a diagram of the usual run time memory
subdivision (memory model) for execution of
programs compiled from languages such as
Pascal and C.  Briefly describe the function of each
of the subdivisions (areas), and discuss
the programming language features which influence
the organisation and functioning of run time storage.
%Comment on how local variables,
%arguments and non-local variables
%are addressed by the code generated for a
%procedure when a run-time stack is in use.
\marks{20}

\subquestion
Explain the purpose of the {\em heap} storage structure and
describe a simple heap allocator.  Explain what is 
meant by {\em fragmentation}, and mention some methods
for reducing fragmention in heaps.  The terms
{\em garbage\/} and {\em dangling pointer} refer to
problems which arise in programming languages which
support explicit deallocation of heap objects. Define
these terms and explain using simple example program
fragments how these problems arise.
%Sketch the simple mark-sweep garbage collection algorithm
%for automatic deallocation of inaccessible heap objects.
\marks{40}

\subquestion

        Explain what is meant by the argument passing mechanisms usually
        known as
                \begin{enumerate}
                \item call-by-value
                \item call-by-reference
                \item call-by-value-result
%                \item call-by-name
                \end{enumerate}
        Deduce for each mechanism what is printed by the 
	following routine:
\begin{verbatim}
       mult (m, n: INTEGER) is
        do
          m := m * n;
          io.putint (m);
          io.putint (n)
        end
\end{verbatim}   
	for the sequence of assigments and two feature calls
        shown below, assuming that both arguments are
	passed with the same mechanism, and that \verb"i" and
	\verb"j" are variable attributes of type INTEGER.
        In each case you must clearly justify your answer.
\begin{verbatim}
       i := 2;
       j := 3;
       mult (i, j);
       mult (i, i)
\end{verbatim}
Although the program is written in Eiffel syntax, the Eiffel
argument-passing semantics do not apply and you must
instead consider each of the mechanisms mentioned, and assume
that it is legal in a routine to assign to a formal argument.
\marks{40}

\end{subquestions}
\end{questions}

\end{document}

