\documentclass{article}

\usepackage{a4wide}
\usepackage[breaklinks=true,
        colorlinks=true,urlcolor=blue,pdfpagemode=None]{hyperref}

\newcommand{\fname}[1]{\texttt{#1}}
\newcommand{\regla}[1]{$\;\mathbf{\stackrel{{}_{#1}}{\longrightarrow}}\;$}
%\newcommand{\regla}[1]{$\mathbf{\rightarrow^{#1}}$}

\newcommand{\comment}{\textbf{comment}}

\begin{document}
\thispagestyle{empty}

\newcommand{\negra}[1]{\textbf{#1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

These document contains the solutions for Tests 1,2 and 3. I have added additional comments, useally preceded by the keyword \comment.


\section*{Test 1 - Solution}

\begin{enumerate}

\item Regular expression: \verb+c? a b* c+

\begin{tabular}{lll}
cbbbbc & NO & \comment: The a is missing.   \\
cabc & YES   \\
abbc & YES & \comment: optional c? not used \\
cac   & YES & \comment: zero length b* \\
abcccc & NO & \comment: string must end with a single character c    \\
\end{tabular}

\item The tokens generated by the lexical analyser are:

\begin{itemize}
\item \verb+x78 if 45 &+ generates: ID(\verb+x78+) IF NUMBER(45) BADCHAR(\verb+&+)
 
\comment: The token definition \verb+[]~+ defines length-one strings made of any character. For example, it will match the first x of the input string but, since the lexical analyser is able to find a longer string i.e. x78, the latter is reported.

\item \verb+78x ifelse 0+ generates: NUMBER(78) ID(\verb+x+) ID(\verb+ifelse+) NUMBER(0)

\comment: ifelse matches two tokens, ID and IFELSE. The first is reported (ID) because it shows up first in the lexical specification.

\item \verb+x$$98+ generates: ID(\verb+x+) BADCHAR(\verb+$+)  BADCHAR(\verb+$+)  NUMBER(98)
\end{itemize}


\item Given alphabet \verb+{x,y}+, what regular expression defines the set of strings that always contain at least one character y?

Answer: \verb+(x|y)* y (x|y)*+

\comment: Regular expressions \verb+y+ and \verb+x*yx*+ define sets of strings that contain at least one character y. However, these sets are limited since they only define a fraction of the set of all possible strings that satisfy this condition. For example, the second regular expression does not contain strings xyxy and yyyy.

\item Regular expression that specifies odd numbers e.g. 1, 3, 227, 1001.

Answer: \verb+ [0-9]* (1 | 3 | 5 | 7 | 9)+

\comment: The set of odd numbers defined by the regular expression above includes numbers that start with zero(es). For example, 0235 is part of the set. If we want to remove these numbers, the regular expression should be defined as follows:

\verb? (1 | 3 | 5 | 7 | 9)  | ([1-9] [0-9]* (1 | 3 | 5 | 7 | 9))  ?

\end{enumerate}

\section*{Test 2 - Solution}

\medskip\noindent Test 2 will cover the following topics:

\begin{itemize}
\item Grammars. You should be able to:
\begin{itemize}
\item Determine if a given string belongs to the language defined by a grammar. In other words, you should be able to generate derivations from a grammar. In particular, leftmost and rightmost derivations.
\item Identify ambiguous and left-recursive grammars, and come-up with a new equivalent grammar that is not ambiguous or left-recursive.
\end{itemize}
\item TPL. Understand the instruction set and be able to write short programs, or code fragments. Understand the main translations from SPL to TPL.
\item SPL. Be familiar with the concrete syntax, JavaCC spec and abstract syntax of SPL. The last lab (and programming assignment) contains the whole JavaCC spec of SPL. 
\item SPL to TPL. Given the syntax of new SPL expressions or statements, you should be able to come up with new abstract syntax, JavaCC specifications and translations into TPL.
\end{itemize}

\section{Derivations/Ambiguous grammars}

Given the grammar:

\begin{tabular}{ll}
\ \\
(1)  & E $\rightarrow$ E + E \\
(2)  & E $\rightarrow$ E - E \\
(3)  & E $\rightarrow$ E * E \\
(4)  & E $\rightarrow$ E / E \\
(5)  & E $\rightarrow$ ( E ) \\
(6) &  E $\rightarrow$ num \\
\end{tabular} \\

and string \textbf{'6 / 3 + (2)'}. Answer the following questions:

\begin{enumerate}
\item Show the leftmost derivation that generates the string. Label each arrow with the appropriate rule number (production rule).

\underline{E} \regla{1} \underline{E} + E \regla{4} \underline{E} / E + E \regla{6} 6 / \underline{E} + E \regla{6} 6 / 3 + \underline{E} \regla{5} 6 / 3 + ( \underline{E} ) \\
\regla{6} 6 / 3 + (2)

A leftmost derivation is one that always expands the leftmost non-terminal. I have underlined the non-terminal being expanded in order to show that, in the derivation above, an expansion/pruduction rule is always applied to the leftmost remaining non-terminal.

\item Show the rightmost derivation.

\underline{E} \regla{1} E + \underline{E} \regla{5} E + ( \underline{E} ) \regla{6} \underline{E} + ( 2 ) \regla{4} E / \underline{E} + (2) \regla{6} \underline{E} / 3 + ( 2 ) \\
\regla{6} 6 / 3 + (2)

It's the same idea, just replace 'leftmost' with 'rightmost'.


\item When is a grammar ambiguous?

A grammar is ambiguous if it can generate two different parse trees for the same string.

\item Is the grammar above ambiguous? Show using your previous answer.


The grammar above is ambiguous. For example, the leftmost derivation shown above, and the derivation shown below:

\underline{E} \regla{4} E / \underline{E} \regla{4} \underline{E} / E + E \regla{6} 6 / \underline{E} + E \regla{6} 6 / 3 + \underline{E} \regla{5} 6 / 3 + ( \underline{E} ) \\
\regla{6} 6 / 3 + (2)

produce two different parse trees:

\begin{verbatim}
         E
         |  
   --------------
   |     |      |
   E     +      E
   |            |
-------     ---------
|  |  |     |   |   |
E  /  E     (   E   )
|     |         |
6     3         2
\end{verbatim}

and 

\begin{verbatim}
         E
         |  
   --------------
   |     |      |
   E     /      E
   |            |
   6        -----------
            |    |    |
            E    +    E
            |         |
            3      ---------
                   |   |   |
                   (   E   )
                       |
                       2
\end{verbatim}

\end{enumerate}

\section{Left-Recursion}

Given the grammar:

\begin{tabular}{ll}
\ \\
(1) L  \regla{}  L ; L \\
(2) L  \regla{} S \\
\end{tabular}

\begin{itemize}
\item Write down 3 strings defined by the grammar above:
\begin{itemize}
\item String \textbf{S}, defined by: L \regla{2} S
\item String \textbf{S ; S}, defined by L \regla{1} L ; L \regla{2} S ; L \regla{2} S ; S.
\item String \textbf{S ; S ; S}, defined by L \regla{1} L ; L \regla{2} S ; L \regla{1} S ; L ; L \regla{2} S ; S ; L \regla{2} S ; S ; S.

\end{itemize}

\item Is the grammar left-recursive? If it is, write down an equivalent grammar that is not left-recursive. Compare with the rulw given  in the lecture notes.
\begin{itemize}
\item Yes, the grammar is left-recursive because the right-hand side of rule L \regla{} L ; L has L as its leftmost non-terminal.
\item We can easliy see that the grammar above defines a non-empty sequence of S's separated by semi-colons. This can be expressed by:

\begin{tabular}{ll}
\ \\
(3)  & L  \regla{}  S  LS\\
(4)  & LS  \regla{} ; S LS \\
(5)  & LS  \regla{} $\epsilon$ \\
\end{tabular} \\

Recall that the rule that removes left-recursion takes a grammar of the form:

\begin{tabular}{l}
\ \\
X  \regla{}  X $\gamma$ \\
X  \regla{} $\alpha$ \\
\end{tabular}

and transforms it into:

\begin{tabular}{l}
\ \\
X  \regla{}  $\alpha$ X' \\
X'  \regla{} $\gamma$ X' \\
X'  \regla{} $\epsilon$ \\
\end{tabular} \\

\noindent which is exactly what happens with our transformation after making $\alpha$ = S and $\gamma$ = ; L, and using LS instead of X'.

\end{itemize}


\item Write down an equivalent grammar using EBNF:

Answer: S (; S)*


\end{itemize}

\section{TPL}

\begin{itemize}

\item Suppose memory locations 2 and 4 are used to store variables x and y, with values 50 and 100.  What does the following code do? Whatâ€™s the output?

\begin{verbatim}
STORE $2, R1
STORE $4, $2
STORE R1, $4   // the first versio moved R1 to $4
WRITEI $2
WRITEI $4
\end{verbatim}

The code swaps the values of x and y and prints the result: 100 50

\item Write code that prints the contents of x n times, where n is the value of y. Do not modify y.

\begin{verbatim}
STORE $4, R1   // R1 will be our counter
LABEL L1
GT R1, 0, R2   // R2 = (R1 > 0)
JMP0 R2, L2    // jump if R2 is false
WRITEI $2
SUBI R1, 1, R1  // decrement counter
JMP L1
LABEL L2

\end{verbatim}

\end{itemize}

\section{SPL to TPL}

Suppose we want to add a short version of a For statement to SPL using the following syntax: \\ 
 
\textit{ForStm} \regla{}  for ( \textit{id} := \textit{Exp} ; \textit{Exp}; \textit{id } := \textit{Exp} )  \textit{Body} \\

where \textit{Body} is a non-empty sequence of statements.

For example, we should be able to write:
\begin{verbatim}
for(x := 0; x < 10; x := x + 1) {  // this is the body
  print(x);
  y := y + x;
}
\end{verbatim}

\begin{itemize}
\item Write down the abstract syntax for \textit{ForStm}.

The abstract syntax gets rid of all elements of the grammar (concrete syntax) that are necessary for parsing (such as punctuation marks, reserved words) and keeps the elements that will be needed for the future passes of the compiler. For example, our For-statement uses the keyword 'for', left and right parenthesis, and semicolons as part of its concrete syntax but only needs to store the names of the ids, three expressions and a list of statements. The abstract syntax can be expressed by: \\

ForStm(Id x1, Id x2, Exp e1, Exp e, Exp e2, Statement+ body) \\

\noindent where e1 corresponds to the first assignment, e to the test and e2 to the second assignment.

\item Write the JavaCC code that parses and creates the AST for the For statement.

\begin{verbatim}
Stm ForStm :
{ Exp e1, e2, e; List<Stm>  body; 
  Token t1, t2;
}
{
  "for" "(" t1=<ID> ":=" e1=Exp() ";" e = Exp() ";" t2=<ID> ":=" e2=Exp() ")"
  body = block()
  { return new ForStm(t1.image, t2.image, e1, e, e2, body); }
}
\end{verbatim}

assuming that their is a constructor for the class ForStm that takes as arguments two strings, 3 objects of class Exp and a list of Stm.

\item Translate ForStm to TPL.
Given abstarct syntax ForStm(Id x1, Id x2, Exp e1, Exp e, Exp e2, Statement+ body), a for-statement is executed as follows:
\begin{enumerate}
\item x1 := e1 is executed.
\item Test e is executed. If it returns true, continue. If it returns false, end execution of statement.
\item Execute each statement in body.
\item Execute x2 := e2
\item goto 2).
\end{enumerate}

Following the sequence above, the translation into TPL will be:

\begin{tabular}{ll}
t1 = stable.getTemp(e1) & \\
a1 = stable.getAddress(x1) & \\
t = stable.getTemp(e) & \\
t2 = stable.getTemp(e2) & \\
a2 = stable.getAddress(x2) & \\
\ \\
Code: & \\
genCode(e1,stable) & //  evaluate e1 - result stored in t1  \\
STORE t1, a1    &  // assign result of e1 into address a1 \\
LABEL L1  & \\
genCode(e, stable) & // evaluate e - result stored in t\\
JMP0 t, L2   & // if result of e is false, jump to L2   \\
genCode(body,stable) &  \\
genCode(e2,stable)  & // evaluate e2 - result stored in t2 \\
STORE t2, a2       &  // assign result of e2 into address a1 \\
JMP L1  &  \\
LABEL L2 &  \\
\end{tabular}

\end{itemize}

\end{document}

