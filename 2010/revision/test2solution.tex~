\documentclass{article}

\usepackage{a4wide}
\usepackage[breaklinks=true,
        colorlinks=true,urlcolor=blue,pdfpagemode=None]{hyperref}

\newcommand{\fname}[1]{\texttt{#1}}
\newcommand{\regla}[1]{$\;\mathbf{\stackrel{{}_{#1}}{\longrightarrow}}\;$}
%\newcommand{\regla}[1]{$\mathbf{\rightarrow^{#1}}$}

\newcommand{\comment}{\textbf{comment}}

\begin{document}
\thispagestyle{empty}

\newcommand{\negra}[1]{\textbf{#1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This document contains the solution for Test 2. I have added additional comments, useally preceded by the keyword \comment.


\section*{Test 2 - Solution}

\begin{enumerate}

\item Given the grammar presented in Question 1.

\begin{itemize}
\item[a.] The strings that can e derived by the non-terminal B of the grammar presented in question 1 are:

\begin{itemize}
\item 'true' (YES) \\

B \regla{4} F \regla{6} true

\item 'true false' (NO) \\

\comment: The only way to get true false is from F F, which can only be generated by B B, which cannot be derived from B.

\item 'x and true or y' (YES). A leftmost derivation: \\

B \regla{1} B and B \regla{4} F and B \regla{5} x and B \regla{2} x and B or B \regla{4} x and F or B \regla{6} x and true or B \regla{4} x and true or F \regla{5} x and true or y

\item 'y ! x' (NO) 
\item 'and x true' (NO) \\
\comment: 'and' can only be between two B's.
\item '!(p and q)' (YES). A rightmost derivation:\\

B \regla{3} !F  \regla{8} !(B) \regla{1} !(B and B) \regla{4} !(B and F) \regla{5} !(B and q) \regla{4} !(F and q) \regla{5} !(p and q) 
\end{itemize}

\comment: The question didn't ask to explain your answer. I have added a complete derivation is the answer was YES, and additional comments to some of the NOs.

\item[b.] Write the leftmost derivation that generates the string 'x and y'.

B \regla{1} B and B \regla{4} F and B \regla{5} x and B \regla{4} x and F \regla{5} x and y


\item[c.] Write the rightmost derivation that generates 'true or (x and y)'.

B \regla{2} B or B \regla{4} B or F \regla{8} B or (B) \regla{1} B or (B and B) \regla{4} B or (B and F) \regla{5} B or (B or y) \regla{4} B or (F or y) \regla{5} B or (x and y) \regla{4} F or (x and y) \regla{6} true or (x and y)
  
\end{itemize}

\comment: Some students could not differentiate between leftmost and rightmost derivations - hopefully the solution will clarify this. Other errors: F must be introduced when, for example, deriving x from B. Finally, I was not very strict with the labelling of derivations -  I will pay more attention when marking the exam.

\comment Try building the parse trees for the derivations above. Is the grammar ambiguous? If this is the case, which strings can be used to show this?

\item Assuming variable x is stored in memory location 4. Write the TPL code that computes \verb?x := x + 2?.

Answer: \verb+    ADDI $4,2,$4+

\comment: The value of memory locations can be accessed by TPL instructions directly: you just need to place \verb+$+ next to the address. ADDI can do the addition and perform a store. The code above is  the shortest answer.

If we restrict operands to constants and registers then we would have to write:
\begin{verbatim}
STORE $4, R1
ADDI R1,2,R1
STORE R1, $4
\end{verbatim}


\item If the initial contents of R1 is integer $n > 0$, what's the final value stored in R3?

\begin{verbatim}
STORE 0, R3      //  R3 = 0
LABEL L1         //  loop entry
GT R1, 0, R2     //  R2 =  R1 > 0
JMP0 R2, L2      //  if R2 is false (R1 <= 0) jump to L2 (exit)
ADDI R3, R1, R3  //  R3 = R3 + R1 (the initial value of R1 is n)
SUBI R1, 1, R1   //  R1 =  R1 - 1
JMP L1           //  go back to loop entry
LABEL L2        // loop exit
\end{verbatim}

Answer: n + (n-1) + (n-2) + ... + 2 + 1

\comment: The code above is equivalent to (pseudo-code):

\begin{verbatim}
R3 = 0;
R1 = n;
while (R1 > 0) {
  R3 = R3 + R1;
  R1 = R1 + 1;
}
\end{verbatim}


\item The syntax of RepeatUntil:

 \begin{tabular}{l}
\textit{RepeatUntilStm} \regla{} \verb+repeat+ \textit{Body} \verb+until+ ( \textit{Exp} )  \\
\textit{Body} \regla{} \verb+{+ \textit{Statement}+ \verb+}+
\end{tabular}

\begin{itemize}

\item[a.] We only need to store the body of the statement (non-empty sequence of statements) and the condition (expression). Therefore, the abstract syntact tree representation can be wirtten as follows:

RepeatUntilStm(List<Stm> body, Exp e)


\item[b.] Write the JavaCC code that parses and creates the AST for the RepeatUntil statement.

\begin{verbatim}
Stm RepeatUntil() :
{ Exp e; List<Stm>  body; 
}
{
  "repeat"   body = block()  "until"   "(" e=Exp() ")"
  { return new RepeatUntilStm(body,e); }
}
\end{verbatim}

assuming that there is a constructor for the class RepeatUntilStm that takes as arguments a list of statements and an expression, and that the non-terminal block() returns a new list of statements.


\item[c.] Translate RepeatUntilStm into TPL.
Given abstract syntax RepeatUntilStm(List<Statement> body, Exp e), a repeatuntil-statement is executed as follows:
\begin{itemize}
\item[1)] Execute each statement of body.
\item[2)] Execute test e. If it returns false, goto 1). If it returns true, end execution of statement.
\end{itemize}

Given the sequence above, the translation into TPL can be defined as follows:

\begin{tabular}{lll}
\multicolumn{3}{l}{Let:} \\
$\;\;\;\;$ & t = stable.getTemp(e) &  \\
& L1 = genLabel() & \\
& s1,s2,...,sn = body & \\
\ \\
\multicolumn{3}{l}{genCode(RepeatUntilStm(body,e)) = } \\
& LABEL L1 & \\
& genCode(s1,stable) & \\
& \ldots & \\
& genCode(sn,stable) & \\
& genCode(e, stable) &  - result of e is stored in t \\
& JMP0 t, L1  &  - if t is false, jump to L1
\end{tabular}

\end{itemize}


\end{enumerate}
%%%%%% end of test 2

\end{document}

