\documentclass{article}

\usepackage{a4wide}
\usepackage[breaklinks=true,
        colorlinks=true,urlcolor=blue,pdfpagemode=None]{hyperref}

\newcommand{\fname}[1]{\texttt{#1}}

\begin{document}
\thispagestyle{empty}

\newcommand{\negra}[1]{\textbf{#1}}

\section*{Language Processors Lab Week 4 - A Simple Calculator }

\medskip\noindent In this lab you will learn how to modify a grammar in JavaCC and how to introduce semantic actions to a .jj file. You will start with a JavaCC file that partially implements the grammar of arithmetical expressions introduced in class. You will complete the grammar and add Java code (semantic actions) that implements a simple calculator of expressions. 

\subsection*{The Exp.jj file}

Start a Unix shell window and move to your LanguageProcessors directory. Create a new directory {\tt lab4} and move inside it. Download the files {\tt Exp.jj} and {\tt Main.java} from CitySpace (week4) - save it to {\tt lab4}. Make sure you load java and javacc by executing the command:

\begin{quote}
{\tt module add java javacc}.
\end{quote}

Start the text editor and load Exp.jj and Main.jj. Inspect their contents: you will see that the JavaCC specification defines a grammar for arithmetical expressions and a parser for that grammar defined by class {\tt Exp}, and that the {\tt Main} class instantiates an {\tt Exp} object, which is used to execute the method {\tt S()}, the entry point to the grammar.

Execute JavaCC, compile the generated java files and execute the program by typing the usual commands:

\begin{verbatim}
    javacc Exp.jj
    javac *.java
    java Main
\end{verbatim}

Test the program with a few examples. This time you have to type {\tt java Main} in order to execute the program because the {\tt Main} class defined in {\tt Main.java} is the one carrying the {\tt static main} method. Also note that in order to test a new expression you will have to run the program again. 

What kind of expressions does it accept? Does it accept parenthesis? Check the grammar against your test results.
For example, enter: {\tt 3+7*9}
What happens? Why?

\subsection*{A grammar for arithmetical expressions: {\tt Exp.jj}}

Why are trying to implement a calculator for arithmetical expressions defined by the following grammar:\\

\begin{tabular}{lcl}
E & $\rightarrow$ & T ( \verb-+- T $|$ \verb+-+ T)$^*$ \\
T & $\rightarrow$ & F ( \verb+*+ F $|$ \verb+/+ F)$^*$ \\
F & $\rightarrow$ & number $|$ \verb+(+ E \verb+)+\\
\end{tabular}

Check the grammar defined in {\tt Exp.jj}. What is missing? In particular check the part of the grammar that specifies the non-terminal {\tt T}. Note that we haven't included the part of the grammar the implements the sequence of factors (F) combined with the multiplication and division operators. Replace the specification of T with the following:

\begin{verbatim}
void T() :
{}
{
  F() ( "*" F() | "/" F() )*
}
\end{verbatim}

Run javacc, compile the program and test it.


\subsubsection*{Adding semantic actions}

The goal of this section is to implement a simple calculator for the expressions defined by the grammar by introducing Java code to different parts of the specification.

The JavaCC specification currently defines (at least) four Java methods, one per non-terminal, with the following signatures:

\begin{verbatim}
void S()        void E()        void T()         void F()
\end{verbatim}

All of them are methods that take no arguments and return nothing. However, our calculator must return an integer. This means that we need to change the signature of the non-terminal methods so they return {\tt int} instead. In particular, we need to:

\begin{itemize}
\item Change {\tt S()} to return the value generated by {\tt E()}:

\begin{verbatim}
int S() :
{ int s; }
{
    s=E() <EOL> { return s; }
  | <EOL>  | <EOF>
}
\end{verbatim}

Note how we have introduced the variable s in order to store the value returned by \verb+E()+.

\item Change {\tt F()} so it calculates the numeric value of the token \verb+<NUM>+ and returns it, or evaluates the expression between parenthesis and returns the result.

\begin{verbatim}
int F() :
{ Token t; int result; }
{
    t=<NUM> { return Integer.parseInt(t.image); }
  | "(" result=E() ")" { return result; }
}
\end{verbatim}

In this case we need two intermediate variables, of types {\tt Token} and {\tt int}.

\item Make sure that the intermediate non-terminals {\tt E()} and {\tt T()} pass the value to the top of the tree:

\begin{verbatim}
int E() :
{ int e; }
{
  e=T() ( "+" T() | "-" T() )* { return e; }
}

int T() :
{ int t; }
{
  t=F() ( "*" F() | "/" F() )* { return t; }
}
\end{verbatim}

\item And finally, the driver method {\tt main} in {\tt Main.java} must print the result of the evaluation. In {\tt Main.java}, replace {\tt parser.S()} with:
\begin{verbatim}
int result = parser.S();
System.out.println("Answer is "+result);
\end{verbatim}
The new code stores the result of {\tt S()} and prints it out.

\end{itemize}

Run javacc, recompile and execute. What happens? \\
For example, what's the return value of {\tt 6 - 8*5}. It's 6. Check again the code and you will notice that we haven't implemented the actual operations. The current code extracts the value of integers but do not do anything with them, the value is just returned. You will always get the leftmost integer e.g. {\tt 5*6 + 7*9} will return 5. Try to understand why. \\

\noindent The fix:

\begin{verbatim}
int E() :
{ int e; int t; }
{
  e=T() (  "+" t=T() { e=e+t; }
         | "-" t=T() { e=e-t; } )*
    { return e; }
}

int T() :
{ int t; int f; }
{
  t=F() (  "*" f=F() { t=t*f; }
         | "/" f=F() { t=t/f; } )*
    { return t; }}
\end{verbatim}

Run javacc, recompile and test. Make sure you understand why it works.
\end{document}

