\documentclass{article}

\usepackage{a4wide}
\usepackage[breaklinks=true,
        colorlinks=true,urlcolor=blue,pdfpagemode=None]{hyperref}

\newcommand{\fname}[1]{\texttt{#1}}

\begin{document}
\thispagestyle{empty}

\newcommand{\negra}[1]{\textbf{#1}}

\section*{Language Processors Lab Week 3 }

\medskip\noindent In this lab we will continue practising with JavaCC and lexical specifications. You will learn how to introduce new tokens and how to mix JavaCC with your own Java code.

\subsection*{The LexInt.jj file}

Start a Unix shell window and move to your LanguageProcessors directory. Create a new directory {\tt lab3} and move inside it. Download the file {\tt LexInt.jj} from CitySpace (week3) - save it to {\tt lab3}. Make sure you load java and javacc by executing the command:

\begin{quote}
{\tt module add java javacc}.
\end{quote}

Start the text editor and load LexTest.jj. Inspect its contents: you will see that the JavaCC specification defines the classes {\tt ParseIntException} and {\tt LexInt}, with an additional static method {\tt parseLiteral}.

Execute JavaCC, compile the generated java files and execute the program by typing the usual commands:

\begin{verbatim}
    javacc LexInt.jj
    javac *.java
    java LexInt
\end{verbatim}

Test the program with a few examples.

\subsection*{Using a text file as input}

You can also test your program by re-directing standard input to a text file. Do the following:
\begin{itemize}
\item Create a new file {\tt test.txt}  using the text editor. Enter a few lines, for example:\\
12 a 00306\\
b ab 6
\item Save the file and type from the command line:
\begin{verbatim}
    java LexInt < test.txt
\end{verbatim}
\end{itemize}

\subsubsection*{Adding new Tokens}

\begin{itemize}
\item A binary literal consists of the leading characters b or B followed by one or more digits 0 or 1 e.g. {\tt b101, B0001, b111101}. Add the token \verb+BINARY_LITERAL+ that implements binary literals.

\noindent \textbf{Solution:} Add a new token to the lexical spefication:
\begin{verbatim}
TOKEN : /* Integers literals */
{
  < INTEGER_LITERAL: "0" | (["1"-"9"] (<DIGIT>)*) >
|
  < BINARY_LITERAL: ("b" | "B") (["0"-"1"])+  >
}
\end{verbatim}

and update the grammar:

\begin{verbatim}
void TokenList() :
{Token t;}
{
   (
     (t = <INTEGER_LITERAL> |  t = <IDENTIFIER> | t=<REAL> |
      t = <BINARY_LITERAL>)
           { System.out.print("token found: "+ tokenImage[t.kind]);
             System.out.println(" (`"+t.image+"')"); 
	   }
   )* <EOF>
}
\end{verbatim}

\item Introduce a new token that implements single line comments. \\
Hint: Use the \verb+~+ operator.

\end{itemize}


\subsubsection*{Manipulating {\tt Token}}

Each token generated by the lexical analyser has a {\tt Token} object associated with it. We can assign this object to a variable e.g. {\tt Token t} and use its contents in the Java code attached to the JavaCC specification. We are currently doing that inside {\tt TokenList}:
\begin{itemize}
\item \verb+tokenImage[t.kind])+ extracts the token's type.
\item \verb+t.image+ extracts the token's content - it returns a string.
\end{itemize}

In particular, the value associated to our \verb+INTEGER_LITERAL+ token is a string. In order to get the integer value we need to evaluate the string  e.g. the value of string '12' must be converted to 12. The {\tt parseLiteral} method does the job. 

Check the implementation of {\tt parseLiteral} and update {\tt TokenList}:

\begin{verbatim}
void TokenList() :
{Token t; int val;}
{
   ( { val = 0;}
     (t = <INTEGER_LITERAL> { val = LexInt.parseLiteral(t.image,10); }
      |  t = <IDENTIFIER> | t=<REAL> |
      t = <BINARY_LITERAL> | t = <COMMENT>)
           { System.out.print("token found: "+ tokenImage[t.kind]);
             System.out.print(" (`"+t.image+"')"); 
             System.out.println(" value = "+val); 
	   }
   )* <EOF>
}
\end{verbatim}

Inspect the new code. How can we do the same for the binary literals?


\end{document}

