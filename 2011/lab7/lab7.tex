\documentclass{article}

\usepackage{a4wide}
\usepackage[breaklinks=true,
        colorlinks=true,urlcolor=blue,pdfpagemode=None]{hyperref}

\newcommand{\fname}[1]{\texttt{#1}}

\begin{document}
\thispagestyle{empty}

\newcommand{\negra}[1]{\textbf{#1}}

\section*{Language Processors Lab 7 (Week8)\\
 The SIMPLE Programming Language: Type-checking and Interpretation}

\medskip\noindent In this lab you will familiarise yourself with the SIMPLE Programming Language, a toy imperative language. You will be asked to extend the language with a new arithmetical expression and a new statement.


\subsection*{Downloading the files}

Start a Unix shell window and move to your LanguageProcessors directory. Download the file {\tt lab7.tar.gz} from Moodle  or from \verb+http://www.soi.city.ac.uk/~sbbc287/lab7.tar.gz+. Unzip and untar the file with the following commands:

\begin{verbatim}
gunzip lab7.tar.gz       // this will genenerate lab6.tar
tar -xvf lab7.tar
\end{verbatim}

The last command will generate the {\tt lab7} directory. It is possible that, while downloading, the file system automatically unzips, and even expands (untars), the file. If that's the case, you may have to skip one or both of the above commands, though make sure to copy the new directory. \\

Your new {\tt lab7} directory should contain one directory: {\tt tpl-interpret} . Double check that this is the case.

Load java and javacc by executing the command:
\begin{verbatim}
      module add java javacc
\end{verbatim}

\subsection*{The SIMPLE Programming Language}

\subsubsection*{Running the typechecker and Interpreter}

Move into the {\tt tpl-interpret} subdirectory, inside the {\tt lab7} directory. \textbf{For example}, if you are in the {\tt LanguageProcessors} directory, type:
\begin{verbatim}
cd lab7/tpl-interpret       
\end{verbatim}

The  {\tt tpl-interpret} directory contains files generated by running the jjtree and javacc command on {\tt TPL.jjt} and {\tt TPL.jj}, respectively. I have deleted some of these generated files in order to avoid version conflicts.

Execute JJTree, JavaCC, and compile the generated java files:

\begin{verbatim}
    jjtree TPL.jjt              javacc TPL.jj               javac *.java
\end{verbatim}

Before runing the program, load in your text editor of choice the contents of {\tt TPL.java}. You should be able to figure out that the main method:
\begin{itemize}
\item Takes a file as input,
\item Parses the contents of the file,
\item And, if succesful, executes the following:
\begin{verbatim}
      ((SimpleNode)parser.jjtree.rootNode()).dump("")
      parser.jjtree.rootNode().identification();
      parser.jjtree.rootNode().typecheck();
      parser.jjtree.rootNode().interpret();
\end{verbatim}
\end{itemize}

The next question should be: What type of files am I going to pass as argument to the program? You should pass files that contain valid SIMPLE programs. We have included a few of these. Look for all files with extension .tpl by typing:
\begin{verbatim}
    ls *.tpl
\end{verbatim}
You should get a few e.g. {\tt fact.tpl}, {\tt rel.tpl}, {\tt types.tpl}, etc.

Now we are ready to test the program. Type:
\begin{verbatim}
    java TPL fact.tpl
\end{verbatim}

You will notice that the program:
\begin{itemize}
\item Prints the AST of the program taken as input.
\item Executes typecheck and identification. However, since there were no type errors, nothing was displayed.
\item Executes the factorial program: it asks a number as input and then prints the value of its factorial.
\end{itemize}

Now try with sqrt.tpl. What does it do?

You can also write your own SIMPLE program!

\subsubsection*{Adding a new operator and expression}

Recall that a few weeks ago you were asked to add the Power operator to your calculator. We can do the same for SIMPLE.

\textbf{Task}: Extend SIMPLE with the power \verb+^+ operator. Assume that the power operator has precedence over plus and minus, that is, \verb+2 - 3 ^ 4+ should be parsed as \verb+2 - (3 ^ 4)+.

\textbf{Solution:} Do the following:
\begin{itemize}
\item You must first modify the SIMPLE syntax so it accepts the new operator. The power operator should also be part of a different type of expression and, consequently, a new type of AST node should be created (by jjtree). Open the {\tt TPL.jjt} file and change the specification for {\tt MultiplicativeExpression} so it looks like:

\begin{verbatim}
void MultiplicativeExpression() #void :
{}
{
  PrimaryExpression()
  (
    "*" PrimaryExpression() #Mul(2)
   |
    "/" PrimaryExpression() #Div(2)
   | 
    "^" PrimaryExpression() #Pow(2)
  )*
}
\end{verbatim}

\item execute {\tt jjtree TPL.jjt}. JJTree should generate an {\tt ASTPow.java} file. Double check that the file has been generated.

\item The new {\tt ASTPow.java} file does not have its own implementations for {\tt identification}, {\tt typecheck} and {\tt interpret}. These implementations (if needed), should be very similar to the other multiplicative expresions e.g. to the ones found in {\tt ASTMul.java}. Have a look and try to figure out the correct version for {\tt ASTPow.java}.

\item Load {\tt ASTPow.java} to your text editor. The implementation for {\tt identification} and {\tt typecheck} should be the same as ASTMul, for example, since both require their operands to be integers. 

Add the following method definitions (you can copy them from ASTMul) to the end of the class definition of {\tt ASTPow}:

\begin{verbatim}
  public void identification () {
    jjtGetChild(0).identification();
    jjtGetChild(1).identification();
  }

  public void typecheck () {
    jjtGetChild(0).typecheck();
    jjtGetChild(1).typecheck();
    if (!(jjtGetChild(0).GetNodeType() == TPLTypes.intType &&
          jjtGetChild(1).GetNodeType() == TPLTypes.intType))
       System.out.println("TPL Typechecker: mult of non-ints.");
    NodeType = TPLTypes.intType;
  }
\end{verbatim}

\item The structure of {\tt interpret} should be very similar to the one used in {\tt ASTMul}. The only diference should be the operation itself: instead of multiplying the numbers you should call {\tt Math.pow}. Type the following after the methods added above:

\begin{verbatim}
  public void interpret () {
    int left, right;
    jjtGetChild(0).interpret();
    jjtGetChild(1).interpret();

    right = ((Integer)stack.pop()).intValue();
    left = ((Integer)stack.pop()).intValue();

    stack.push(new Integer((int)Math.pow(left,right)));
  }
\end{verbatim}

\item Run {\tt javacc TPL.jj} and compile the new file with {\tt javac *.java}.

\item In order to test our new construct we need a SIMPLE program that uses the power operation. Create a new file {\tt cube.tpl} containing the following:
\begin{verbatim}
int n;
int c;

read n;
c  = n ^ 3;
write c;
\end{verbatim}

\item Run the program with {\tt java TPL cube.tpl}.\\
Does it work? It should!

\end{itemize}

\subsection*{Adding a new statement}

The SIMPLE Programming language contains one statement for  building loops: the while statement. Supposse we want to extend SIMPLE with a {\tt repeat} stament that has the following syntax:

\begin{verbatim}
RepeatStatement  -->   "repeat" "(" Expression ")" StatementBlock
\end{verbatim}

Thus, we should be able to write programs with code like this:

\begin{verbatim}
.....
x = y * 4;
repeat (x+10) { y = y*2; write(y); }
\end{verbatim}

A Repeat statement first evaluates the expression in parenthesis (the result must be an integer), say to integer n,  and then evaluates the block of statements n times.

\textbf{Task:} Add the repeat statement to SIMPLE. Hint: Check the implementation of the while statement.

\textbf{Solution:} Out on Wednesday.

\end{document}

