/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. TPL.jj */
/*@egen*/options {
              
}

PARSER_BEGIN(TPLParser)

public class TPLParser/*@bgen(jjtree)*/implements TPLParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTTPLParserState jjtree = new JJTTPLParserState();

/*@egen*/
}

PARSER_END(TPLParser)

/*
 * Lexical items.
 */

SKIP : /* WHITE SPACE */
{
  " "
| "\t"		/* Tab */
| "\n"		/* Newline */
| "\r"		/* Return */
| "\f"		/* Formfeed */
}

TOKEN : { < KEYSKIP: "skip" > }
TOKEN : { < KEYWHILE: "while" > }
TOKEN : { < KEYFOR: "for" > }           /* keyword "for". */
TOKEN : { < KEYIF: "if" > }
TOKEN : { < KEYTHEN: "then" > }
TOKEN : { < KEYELSE: "else" > }
TOKEN : { < KEYREAD: "read" > }
TOKEN : { < KEYWRITE: "write" > }
TOKEN : { < KEYAND: "and" > }		/* Operator. */
TOKEN : { < KEYOR: "or" > }		/* Operator. */

TOKEN : /* Type names. */
{
   < KEYINT: "int" >
 |
   < KEYBOOL: "boolean" >
}

TOKEN : /* Literal integers. */
{
  < INTEGER_LITERAL: (<DIGIT>)+ >
}

TOKEN : /* Literal booleans. */
{
  < KEYTRUE: "true" >
 |
  < KEYFALSE: "false" >
}

TOKEN : /* Identifiers. */
{
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
}

TOKEN : /* Definitions for use in other lexical definitions
           (signified by the `#'). */
{
  < #LETTER: [ "a"-"z", "A"-"Z" ] >
|
  < #DIGIT: [ "0"-"9"] >
}

/*
 * TPL grammar follows.
 */

void CompilationUnit() : /* By default will create ASTCompilationUnit node. */
{/*@bgen(jjtree) CompilationUnit */
  ASTCompilationUnit jjtn000 = new ASTCompilationUnit(JJTCOMPILATIONUNIT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CompilationUnit */
   try {
/*@egen*/
   ( VarDeclaration() ";" )*
   ( Statement() )*
   <EOF>/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

void VarDeclaration() :	/* By default will create ASTVarDeclaration nodes. */
{/*@bgen(jjtree) VarDeclaration */
  ASTVarDeclaration jjtn000 = new ASTVarDeclaration(JJTVARDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) VarDeclaration */
  try {
/*@egen*/
  (		/* `type' declared in ASTVarDeclaration.java. */
    <KEYBOOL> { jjtn000.type = TPLTypes.boolType; }
   |
    <KEYINT> { jjtn000.type = TPLTypes.intType; }
  )
  t = <IDENTIFIER>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { jjtn000.name = t.image; }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/	/* `name' declared in ASTVarDec.java. */
				/* `image' is the text of the token. */
}


/*
 * Statement syntax follows.
 */

void Statement()       :	/* `#void' means create no default nodes. */
{}
{
  SkipStatement()
|
  AssignStatement()
|
  IfStatement()
|
  WhileStatement()
|
  ForStatement()             /* Added "for" statement. */
|
  ReadStatement()
|
  WriteStatement()
}

void SkipStatement():	/* By default will create ASTSkipStatement nodes. */
{/*@bgen(jjtree) SkipStatement */
  ASTSkipStatement jjtn000 = new ASTSkipStatement(JJTSKIPSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SkipStatement */
  try {
/*@egen*/
  <KEYSKIP> ";"/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void AssignStatement():	/* By default will create ASTAssignStatement nodes. */
{/*@bgen(jjtree) AssignStatement */
  ASTAssignStatement jjtn000 = new ASTAssignStatement(JJTASSIGNSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AssignStatement */
  try {
/*@egen*/
  Id() "=" Expression() ";"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void IfStatement() :	/* By default will create ASTIfStatement nodes. */
{/*@bgen(jjtree) IfStatement */
  ASTIfStatement jjtn000 = new ASTIfStatement(JJTIFSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) IfStatement */
  try {
/*@egen*/
  <KEYIF> "(" Expression() ")"
      StatementBlock()
      [ <KEYELSE> StatementBlock() ]/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void WhileStatement() :	/* By default will create ASTWhileStatement nodes. */
{/*@bgen(jjtree) WhileStatement */
  ASTWhileStatement jjtn000 = new ASTWhileStatement(JJTWHILESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) WhileStatement */
  try {
/*@egen*/
  <KEYWHILE> "(" Expression() ")" StatementBlock()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void UpdateStatement() :   /* For use with "for" statement. */
{/*@bgen(jjtree) UpdateStatement */
  ASTUpdateStatement jjtn000 = new ASTUpdateStatement(JJTUPDATESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) UpdateStatement */
  try {
/*@egen*/
  Id() "=" Expression()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


void ForStatement() :	/* Added "for" statement. */
{/*@bgen(jjtree) ForStatement */
  ASTForStatement jjtn000 = new ASTForStatement(JJTFORSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ForStatement */
  try {
/*@egen*/
  <KEYFOR> "(" AssignStatement() Expression() ";" UpdateStatement() ")"
      StatementBlock()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void StatementBlock() : /* By default will create ASTStatementBlock nodes. */
{/*@bgen(jjtree) StatementBlock */
  ASTStatementBlock jjtn000 = new ASTStatementBlock(JJTSTATEMENTBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) StatementBlock */
    try {
/*@egen*/
    "{" ( Statement() )+ "}"/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ReadStatement() :	/* By default will create ASTReadStatement nodes. */
{/*@bgen(jjtree) ReadStatement */
  ASTReadStatement jjtn000 = new ASTReadStatement(JJTREADSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) ReadStatement */
   try {
/*@egen*/
   <KEYREAD> t = <IDENTIFIER> ";"/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/
   { jjtn000.name = t.image; }/*@bgen(jjtree)*/
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/	/* `name' declared in ASTReadStatement.java. */
}

void WriteStatement() :	/* By default will create ASTWriteStatement nodes. */
{/*@bgen(jjtree) WriteStatement */
  ASTWriteStatement jjtn000 = new ASTWriteStatement(JJTWRITESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) WriteStatement */
   try {
/*@egen*/
   <KEYWRITE> t = <IDENTIFIER> ";"/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/
   { jjtn000.name = t.image; }/*@bgen(jjtree)*/
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/	/* `name' declared in ASTWriteStatement.java. */
}


/*
 * Expression syntax follows.
 */

void Expression()      :
{}
{
  OrExpression()
}

void OrExpression()       :
{}
{
  AndExpression()
  ( "or"/*@bgen(jjtree) #Or( 2) */
         {
           ASTOr jjtn001 = new ASTOr(JJTOR);
           boolean jjtc001 = true;
           jjtree.openNodeScope(jjtn001);
         }
         try {
/*@egen*/ AndExpression()/*@bgen(jjtree)*/
         } catch (Throwable jjte001) {
           if (jjtc001) {
             jjtree.clearNodeScope(jjtn001);
             jjtc001 = false;
           } else {
             jjtree.popNode();
           }
           if (jjte001 instanceof RuntimeException) {
             throw (RuntimeException)jjte001;
           }
           if (jjte001 instanceof ParseException) {
             throw (ParseException)jjte001;
           }
           throw (Error)jjte001;
         } finally {
           if (jjtc001) {
             jjtree.closeNodeScope(jjtn001,  2);
           }
         }
/*@egen*/        )*	/* create ASTOr node for each `or'. */
}

void AndExpression()       :
{}
{
  EqualityExpression()
  ( "and"/*@bgen(jjtree) #And( 2) */
          {
            ASTAnd jjtn001 = new ASTAnd(JJTAND);
            boolean jjtc001 = true;
            jjtree.openNodeScope(jjtn001);
          }
          try {
/*@egen*/ EqualityExpression()/*@bgen(jjtree)*/
          } catch (Throwable jjte001) {
            if (jjtc001) {
              jjtree.clearNodeScope(jjtn001);
              jjtc001 = false;
            } else {
              jjtree.popNode();
            }
            if (jjte001 instanceof RuntimeException) {
              throw (RuntimeException)jjte001;
            }
            if (jjte001 instanceof ParseException) {
              throw (ParseException)jjte001;
            }
            throw (Error)jjte001;
          } finally {
            if (jjtc001) {
              jjtree.closeNodeScope(jjtn001,  2);
            }
          }
/*@egen*/         )*
}

void EqualityExpression()       :
{}
{
  RelationalExpression()
  (
     "=="/*@bgen(jjtree) #EQ( 2) */
          {
            ASTEQ jjtn001 = new ASTEQ(JJTEQ);
            boolean jjtc001 = true;
            jjtree.openNodeScope(jjtn001);
          }
          try {
/*@egen*/ RelationalExpression()/*@bgen(jjtree)*/
          } catch (Throwable jjte001) {
            if (jjtc001) {
              jjtree.clearNodeScope(jjtn001);
              jjtc001 = false;
            } else {
              jjtree.popNode();
            }
            if (jjte001 instanceof RuntimeException) {
              throw (RuntimeException)jjte001;
            }
            if (jjte001 instanceof ParseException) {
              throw (ParseException)jjte001;
            }
            throw (Error)jjte001;
          } finally {
            if (jjtc001) {
              jjtree.closeNodeScope(jjtn001,  2);
            }
          }
/*@egen*/       
   |
     "!="/*@bgen(jjtree) #NE( 2) */
          {
            ASTNE jjtn002 = new ASTNE(JJTNE);
            boolean jjtc002 = true;
            jjtree.openNodeScope(jjtn002);
          }
          try {
/*@egen*/ RelationalExpression()/*@bgen(jjtree)*/
          } catch (Throwable jjte002) {
            if (jjtc002) {
              jjtree.clearNodeScope(jjtn002);
              jjtc002 = false;
            } else {
              jjtree.popNode();
            }
            if (jjte002 instanceof RuntimeException) {
              throw (RuntimeException)jjte002;
            }
            if (jjte002 instanceof ParseException) {
              throw (ParseException)jjte002;
            }
            throw (Error)jjte002;
          } finally {
            if (jjtc002) {
              jjtree.closeNodeScope(jjtn002,  2);
            }
          }
/*@egen*/       
  )*
}

void RelationalExpression()       :
{}
{
  AdditiveExpression()
  [ (
    "<"/*@bgen(jjtree) #LT( 2) */
        {
          ASTLT jjtn001 = new ASTLT(JJTLT);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/ AdditiveExpression()/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
          }
        }
/*@egen*/       
   |
    ">"/*@bgen(jjtree) #GT( 2) */
        {
          ASTGT jjtn002 = new ASTGT(JJTGT);
          boolean jjtc002 = true;
          jjtree.openNodeScope(jjtn002);
        }
        try {
/*@egen*/ AdditiveExpression()/*@bgen(jjtree)*/
        } catch (Throwable jjte002) {
          if (jjtc002) {
            jjtree.clearNodeScope(jjtn002);
            jjtc002 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte002 instanceof RuntimeException) {
            throw (RuntimeException)jjte002;
          }
          if (jjte002 instanceof ParseException) {
            throw (ParseException)jjte002;
          }
          throw (Error)jjte002;
        } finally {
          if (jjtc002) {
            jjtree.closeNodeScope(jjtn002,  2);
          }
        }
/*@egen*/       
   |
    "<="/*@bgen(jjtree) #LE( 2) */
         {
           ASTLE jjtn003 = new ASTLE(JJTLE);
           boolean jjtc003 = true;
           jjtree.openNodeScope(jjtn003);
         }
         try {
/*@egen*/ AdditiveExpression()/*@bgen(jjtree)*/
         } catch (Throwable jjte003) {
           if (jjtc003) {
             jjtree.clearNodeScope(jjtn003);
             jjtc003 = false;
           } else {
             jjtree.popNode();
           }
           if (jjte003 instanceof RuntimeException) {
             throw (RuntimeException)jjte003;
           }
           if (jjte003 instanceof ParseException) {
             throw (ParseException)jjte003;
           }
           throw (Error)jjte003;
         } finally {
           if (jjtc003) {
             jjtree.closeNodeScope(jjtn003,  2);
           }
         }
/*@egen*/       
   |
    ">="/*@bgen(jjtree) #GE( 2) */
         {
           ASTGE jjtn004 = new ASTGE(JJTGE);
           boolean jjtc004 = true;
           jjtree.openNodeScope(jjtn004);
         }
         try {
/*@egen*/ AdditiveExpression()/*@bgen(jjtree)*/
         } catch (Throwable jjte004) {
           if (jjtc004) {
             jjtree.clearNodeScope(jjtn004);
             jjtc004 = false;
           } else {
             jjtree.popNode();
           }
           if (jjte004 instanceof RuntimeException) {
             throw (RuntimeException)jjte004;
           }
           if (jjte004 instanceof ParseException) {
             throw (ParseException)jjte004;
           }
           throw (Error)jjte004;
         } finally {
           if (jjtc004) {
             jjtree.closeNodeScope(jjtn004,  2);
           }
         }
/*@egen*/       
  ) ]
}

void AdditiveExpression()       :
{}
{
  MultiplicativeExpression()
  (
    "+"/*@bgen(jjtree) #Add( 2) */
        {
          ASTAdd jjtn001 = new ASTAdd(JJTADD);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/ MultiplicativeExpression()/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
          }
        }
/*@egen*/        
   |
    "-"/*@bgen(jjtree) #Subtract( 2) */
        {
          ASTSubtract jjtn002 = new ASTSubtract(JJTSUBTRACT);
          boolean jjtc002 = true;
          jjtree.openNodeScope(jjtn002);
        }
        try {
/*@egen*/ MultiplicativeExpression()/*@bgen(jjtree)*/
        } catch (Throwable jjte002) {
          if (jjtc002) {
            jjtree.clearNodeScope(jjtn002);
            jjtc002 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte002 instanceof RuntimeException) {
            throw (RuntimeException)jjte002;
          }
          if (jjte002 instanceof ParseException) {
            throw (ParseException)jjte002;
          }
          throw (Error)jjte002;
        } finally {
          if (jjtc002) {
            jjtree.closeNodeScope(jjtn002,  2);
          }
        }
/*@egen*/             
  )*
}

void MultiplicativeExpression()       :
{}
{
  PrimaryExpression()
  (
    "*"/*@bgen(jjtree) #Mul( 2) */
        {
          ASTMul jjtn001 = new ASTMul(JJTMUL);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/ PrimaryExpression()/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
          }
        }
/*@egen*/        
   |
    "/"/*@bgen(jjtree) #Div( 2) */
        {
          ASTDiv jjtn002 = new ASTDiv(JJTDIV);
          boolean jjtc002 = true;
          jjtree.openNodeScope(jjtn002);
        }
        try {
/*@egen*/ PrimaryExpression()/*@bgen(jjtree)*/
        } catch (Throwable jjte002) {
          if (jjtc002) {
            jjtree.clearNodeScope(jjtn002);
            jjtc002 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte002 instanceof RuntimeException) {
            throw (RuntimeException)jjte002;
          }
          if (jjte002 instanceof ParseException) {
            throw (ParseException)jjte002;
          }
          throw (Error)jjte002;
        } finally {
          if (jjtc002) {
            jjtree.closeNodeScope(jjtn002,  2);
          }
        }
/*@egen*/        
   |
    "^"/*@bgen(jjtree) #Pow( 2) */
        {
          ASTPow jjtn003 = new ASTPow(JJTPOW);
          boolean jjtc003 = true;
          jjtree.openNodeScope(jjtn003);
        }
        try {
/*@egen*/ PrimaryExpression()/*@bgen(jjtree)*/
        } catch (Throwable jjte003) {
          if (jjtc003) {
            jjtree.clearNodeScope(jjtn003);
            jjtc003 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte003 instanceof RuntimeException) {
            throw (RuntimeException)jjte003;
          }
          if (jjte003 instanceof ParseException) {
            throw (ParseException)jjte003;
          }
          throw (Error)jjte003;
        } finally {
          if (jjtc003) {
            jjtree.closeNodeScope(jjtn003,  2);
          }
        }
/*@egen*/        
  )*
}

void PrimaryExpression()       :
{}
{
  Literal()
|
  Id()
|
  "(" Expression() ")"
}

void Id() :	/* By default will create ASTId leaves (no children). */
{/*@bgen(jjtree) Id */
   ASTId jjtn000 = new ASTId(JJTID);
   boolean jjtc000 = true;
   jjtree.openNodeScope(jjtn000);
/*@egen*/
   Token t;
}
{/*@bgen(jjtree) Id */
   try {
/*@egen*/
   t = <IDENTIFIER>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
        { jjtn000.name = t.image; }/*@bgen(jjtree)*/
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/	/* `name' declared in ASTId.java. */
}

void Literal()       :
{
   Token t;
}
{/*@bgen(jjtree) IntConst */
 {
   ASTIntConst jjtn001 = new ASTIntConst(JJTINTCONST);
   boolean jjtc001 = true;
   jjtree.openNodeScope(jjtn001);
 }
 try {
/*@egen*/
 (
  t=<INTEGER_LITERAL>/*@bgen(jjtree)*/
                      {
                        jjtree.closeNodeScope(jjtn001, true);
                        jjtc001 = false;
                      }
/*@egen*/ { jjtn001.val = Integer.parseInt(t.image);}
				/* `val' declared in ASTIntConst.java. */
 )/*@bgen(jjtree)*/
 } finally {
   if (jjtc001) {
     jjtree.closeNodeScope(jjtn001, true);
   }
 }
/*@egen*/          		/* Create an ASTIntConst leaf (note no children). */
|
  BooleanLiteral()
}

void BooleanLiteral()       :
{}
{/*@bgen(jjtree) True */
  {
    ASTTrue jjtn001 = new ASTTrue(JJTTRUE);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
  }
  try {
/*@egen*/
  "true"/*@bgen(jjtree)*/
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, true);
    }
  }
/*@egen*/      		/* Create an ASTTrue leaf (note no children). */
|/*@bgen(jjtree) False */
  {
    ASTFalse jjtn002 = new ASTFalse(JJTFALSE);
    boolean jjtc002 = true;
    jjtree.openNodeScope(jjtn002);
  }
  try {
/*@egen*/
  "false"/*@bgen(jjtree)*/
  } finally {
    if (jjtc002) {
      jjtree.closeNodeScope(jjtn002, true);
    }
  }
/*@egen*/       	/* Create an ASTTrue leaf (note no children). */
}
